{"ast":null,"code":"/*! @azure/msal-common v4.3.0 2021-05-12 */\n'use strict';\n\nimport { __extends, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BaseClient } from './BaseClient.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { TimeUtils } from '../utils/TimeUtils.js';\nimport { RefreshTokenClient } from './RefreshTokenClient.js';\nimport { ClientAuthError, ClientAuthErrorMessage } from '../error/ClientAuthError.js';\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.js';\nimport { ResponseHandler } from '../response/ResponseHandler.js';\nimport { AuthenticationScheme } from '../utils/Constants.js';\nimport { StringUtils } from '../utils/StringUtils.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar SilentFlowClient =\n/** @class */\nfunction (_super) {\n  __extends(SilentFlowClient, _super);\n\n  function SilentFlowClient(configuration) {\n    return _super.call(this, configuration) || this;\n  }\n  /**\r\n   * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew\r\n   * the given token and returns the renewed token\r\n   * @param request\r\n   */\n\n\n  SilentFlowClient.prototype.acquireToken = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1, refreshTokenClient;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.acquireCachedToken(request)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 2:\n            e_1 = _a.sent();\n\n            if (e_1 instanceof ClientAuthError && e_1.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {\n              refreshTokenClient = new RefreshTokenClient(this.config);\n              return [2\n              /*return*/\n              , refreshTokenClient.acquireTokenByRefreshToken(request)];\n            } else {\n              throw e_1;\n            }\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Retrieves token from cache or throws an error if it must be refreshed.\r\n   * @param request\r\n   */\n\n\n  SilentFlowClient.prototype.acquireCachedToken = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var requestScopes, environment, authScheme, cacheRecord;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Cannot renew token if no request object is given.\n            if (!request) {\n              throw ClientConfigurationError.createEmptyTokenRequestError();\n            } // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n\n\n            if (!request.account) {\n              throw ClientAuthError.createNoAccountInSilentRequestError();\n            }\n\n            requestScopes = new ScopeSet(request.scopes || []);\n            environment = request.authority || this.authority.getPreferredCache();\n            authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n            cacheRecord = this.cacheManager.readCacheRecord(request.account, this.config.authOptions.clientId, requestScopes, environment, authScheme);\n\n            if (request.forceRefresh || !StringUtils.isEmptyObj(request.claims) || !cacheRecord.accessToken || TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds) || cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {\n              // Must refresh due to request parameters, or expired or non-existent access_token\n              throw ClientAuthError.createRefreshRequiredError();\n            }\n\n            if (this.config.serverTelemetryManager) {\n              this.config.serverTelemetryManager.incrementCacheHits();\n            }\n\n            return [4\n            /*yield*/\n            , this.generateResultFromCacheRecord(cacheRecord, request)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n  /**\r\n   * Helper function to build response object from the CacheRecord\r\n   * @param cacheRecord\r\n   */\n\n\n  SilentFlowClient.prototype.generateResultFromCacheRecord = function (cacheRecord, request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var idTokenObj;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (cacheRecord.idToken) {\n              idTokenObj = new AuthToken(cacheRecord.idToken.secret, this.config.cryptoInterface);\n            }\n\n            return [4\n            /*yield*/\n            , ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenObj)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n\n  return SilentFlowClient;\n}(BaseClient);\n\nexport { SilentFlowClient };","map":{"version":3,"sources":["../../src/client/SilentFlowClient.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { BaseClient } from \"./BaseClient\";\r\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\r\nimport { CommonSilentFlowRequest } from \"../request/CommonSilentFlowRequest\";\r\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { AuthToken } from \"../account/AuthToken\";\r\nimport { TimeUtils } from \"../utils/TimeUtils\";\r\nimport { RefreshTokenClient } from \"./RefreshTokenClient\";\r\nimport { ClientAuthError, ClientAuthErrorMessage } from \"../error/ClientAuthError\";\r\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\r\nimport { ResponseHandler } from \"../response/ResponseHandler\";\r\nimport { CacheRecord } from \"../cache/entities/CacheRecord\";\r\nimport { AuthenticationScheme } from \"../utils/Constants\";\r\nimport { StringUtils } from \"../utils/StringUtils\";\r\n\r\nexport class SilentFlowClient extends BaseClient {\r\n\r\n    constructor(configuration: ClientConfiguration) {\r\n        super(configuration);\r\n    }\r\n\r\n    /**\r\n     * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew\r\n     * the given token and returns the renewed token\r\n     * @param request\r\n     */\r\n    async acquireToken(request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\r\n        try {\r\n            return await this.acquireCachedToken(request);\r\n        } catch (e) {\r\n            if (e instanceof ClientAuthError && e.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {\r\n                const refreshTokenClient = new RefreshTokenClient(this.config);\r\n                return refreshTokenClient.acquireTokenByRefreshToken(request);\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves token from cache or throws an error if it must be refreshed.\r\n     * @param request\r\n     */\r\n    async acquireCachedToken(request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\r\n        // Cannot renew token if no request object is given.\r\n        if (!request) {\r\n            throw ClientConfigurationError.createEmptyTokenRequestError();\r\n        }\r\n\r\n        // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\r\n        if (!request.account) {\r\n            throw ClientAuthError.createNoAccountInSilentRequestError();\r\n        }\r\n        const requestScopes = new ScopeSet(request.scopes || []);\r\n        const environment = request.authority || this.authority.getPreferredCache();\r\n        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\r\n        const cacheRecord = this.cacheManager.readCacheRecord(request.account, this.config.authOptions.clientId, requestScopes, environment, authScheme);\r\n\r\n        if (request.forceRefresh || \r\n            !StringUtils.isEmptyObj(request.claims) || \r\n            !cacheRecord.accessToken || \r\n            TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds) ||\r\n            (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0))) {\r\n            // Must refresh due to request parameters, or expired or non-existent access_token\r\n            throw ClientAuthError.createRefreshRequiredError();\r\n        }\r\n\r\n        if (this.config.serverTelemetryManager) {\r\n            this.config.serverTelemetryManager.incrementCacheHits();\r\n        }\r\n\r\n        return await this.generateResultFromCacheRecord(cacheRecord, request);\r\n    }\r\n\r\n    /**\r\n     * Helper function to build response object from the CacheRecord\r\n     * @param cacheRecord\r\n     */\r\n    private async generateResultFromCacheRecord(cacheRecord: CacheRecord, request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\r\n        let idTokenObj: AuthToken | undefined;\r\n        if (cacheRecord.idToken) {\r\n            idTokenObj = new AuthToken(cacheRecord.idToken.secret, this.config.cryptoInterface);\r\n        }\r\n        return await ResponseHandler.generateAuthenticationResult(\r\n            this.cryptoUtils,\r\n            this.authority,\r\n            cacheRecord,\r\n            true,\r\n            request,\r\n            idTokenObj\r\n        );\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}